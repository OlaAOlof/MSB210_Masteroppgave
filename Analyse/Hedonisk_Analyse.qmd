---
title: "Masteroppgave"
author: 
  Kevin Ha
  Ola Andre Olofsson
format: html
editor: visual
---

# Setup Chunk

```{r setup_base}
library(readr)
library(tidyverse)
library(dplyr)
library(lubridate)
#library(zoo)
library(sf)
library(sp)
library(spdep)
library(tmap)
library(spatialreg)
#library(magrittr)
#library(measurements)
library(tibble)
library(ggcorrplot)
library(huxtable)
library(plm)
library(car)
options(paged.print = FALSE)
```

# Leser inn datasettene for analyse

```{r}
Analyse <- suppressWarnings(read_csv("Datasett_Analyse.csv")) %>% 
  select(-...1)
Analyse_sf <- suppressWarnings(st_read("Datasett_Analyse_sf.gpkg"))
Analyse_Shape <- suppressWarnings(read_sf("Analyse_Shape.shp"))
```

```{r}
shp <- "Analyse_Shape.shp"
class(st_geometry(st_read(shp, quiet = TRUE, type = 3)))
```

# Summary av Datasettene

```{r}
#summary(Analyse)
summary(Analyse_sf)
```

# Lager vektmatriser

```{r}

#Kankje laga vektmatrisa på Analyse-datasettet. Må bli gjort på kart-datasettet "Analyse_sf"

#Analyse_mat_nb3 <- knearneigh(Analyse, k = 3)
#Analyse_nb3 <- knn2nb(Analyse_mat_nb3)
#Analyse_W3 <- nb2listw(Analyse_nb3, style = "W")
```

## Vektmatrise for Analyse_sf

### Tester Queen- og Rook

```{r}
queen.nb = poly2nb(Analyse_Shape)
```

```{r}
queen.listw = nb2listw(queen.nb)
```

```{r}
rook.nb = poly2nb(Analyse_Shape, queen = FALSE)
```

```{r}
rook.listw = nb2listw(rook.nb)
```

```{r}
listw1 = queen.listw
```

### Tester K-nærmeste-naboer-metoden
Her bruker vi den k-nærmeste naboer-metoden, som baserer seg på avstanden mellom punktene.
Queen- og Rook-kriteriene brukes for å definere naboer i polygondata. Queen-kriteriet sier at polygoner er naboer hvis de deler minst ett punkt (hjørne eller kant), mens Rook-kriteriet sier at polygoner er naboer hvis de deler minst en kant.

K-nærmeste naboer-metoden som brukes fremvoer fungerer for punktdata og definerer naboer basert på avstanden mellom punktene. For hver observasjon finner den k nærmeste naboene, der k er en forhåndsbestemt verdi (k = 3, k = 5 og k = 10).

#### Vektmatrise, K = 3
Oppretter romlige vektmatriser for k-nærmeste naboer med k = 3
```{r}
Analyse_sf_mat_nb3 <- knearneigh(Analyse_sf, k = 3)
Analyse_sf_nb3 <- knn2nb(Analyse_sf_mat_nb3)
Analyse_sf_W3 <- nb2listw(Analyse_sf_nb3, style = "W")
```

#### Vektmatrise, K = 5
Oppretter romlige vektmatriser for k-nærmeste naboer med k = 5
```{r}
Analyse_sf_mat_nb5 <- knearneigh(Analyse_sf, k = 5)
Analyse_sf_nb5 <- knn2nb(Analyse_sf_mat_nb5)
Analyse_sf_W5 <- nb2listw(Analyse_sf_nb5, style = "W")
```

#### Vektmatrise, K = 10
Oppretter romlige vektmatriser for k-nærmeste naboer med k = 10
```{r}
Analyse_sf_mat_nb10 <- knearneigh(Analyse_sf, k = 10)
Analyse_sf_nb10 <- knn2nb(Analyse_sf_mat_nb10)
Analyse_sf_W10 <- nb2listw(Analyse_sf_nb10, style = "W")
```

# Kevin nabolagsmatrise

```{r}
# Nå plotter vi punktene og naboene for et utvalg av punkter for å se om det ser ut som om de har riktig antall naboer (k = 10).
plot(st_geometry(Analyse_sf), pch = 19, cex = 0.5, col = "blue")

# Velg et punkt for å se naboene
point_index <- 1

# Plot de valgte pointsene og naboene
plot(Analyse_sf[point_index, ], col = "red", pch = 19, cex = 1.2, add = TRUE)
plot(Analyse_sf[names(Analyse_sf_nb10[[point_index]]), ], col = "green", pch = 19, cex = 10, add = TRUE)

# Legger til beskrivelse
legend("bottomright", legend = c("Points", "Selected point", "Naboer (k = 10)"),
       col = c("blue", "red", "green"), pch = 19, cex = 0.8)
```

# Kevin Morans I
```{r Kevins Moran}
# Definer en variabel for romlig analyse
Pris <- Analyse_sf$P

# Beregn Global Moran's I for k = 3, k = 5 og k = 10
moran_3 <- moran.test(Pris, Analyse_sf_W3)
moran_5 <- moran.test(Pris, Analyse_sf_W5)
moran_10 <- moran.test(Pris, Analyse_sf_W10)

# Vis resultater
cat("Global Moran's I (k = 3):", moran_3$estimate, "\n")
cat("Global Moran's I (k = 5):", moran_5$estimate, "\n")
cat("Global Moran's I (k = 10):", moran_10$estimate, "\n")
```
Disse resultatene viser Global Moran's I-verdier for k = 3, k = 5 og k = 10. Global Moran's I er et mål på romlig autokorrelasjon som gir en indikasjon på hvordan en variabel (i dette tilfellet "Pris") er korrelert med seg selv i rommet. I dette tilfellet er variabelen "Pris" korrelert med sine nærmeste naboer.

Resultatene viser følgende:
Global Moran's I (k = 3): 0.3930968
Global Moran's I (k = 5): 0.3361125
Global Moran's I (k = 10): 0.2473997
Global Moran's I-verdier varierer mellom -1 og 1:

Verdier nær 1 indikerer positiv romlig autokorrelasjon, der lignende verdier er gruppert sammen i rommet.
Verdier nær -1 indikerer negativ romlig autokorrelasjon, der ulike verdier er gruppert sammen i rommet.
Verdier nær 0 indikerer ingen romlig autokorrelasjon, der verdier er jevnt fordelt i rommet.
I dette tilfellet er alle Global Moran's I-verdier positive, noe som tyder på positiv romlig autokorrelasjon. Det betyr at høyere priser har en tendens til å være nærmere hverandre, og lavere priser har en tendens til å være nærmere hverandre i rommet.

Det er viktig å merke seg at Moran's I-verdien avtar når antall naboer (k) øker. Dette kan skyldes at når flere naboer inkluderes i analysen, blir det mindre sannsynlig at hver enhet har naboer med lignende verdier.

Tallene etter Moran's I-verdiene i resultatene (-0.0003374958 og 0.0001646533 for k = 3, osv.) er konstantleddet og koeffisienten for x i Moran's I-beregningen. Disse tallene brukes for å beregne Moran's I-verdien og er ikke av stor interesse for tolkningen av resultatene.

```{r Kevins modell}
# Konverter Analyse_sf til en pdata.frame for romlig regresjon
analyse_sf_pdata <- pdata.frame(Analyse_sf)

# Definer modellformel
Kev_model <- "P ~ Alder + EL.Kar + Bruksareal.Enhet + dist_cbd_km"

# Utfør romlig regresjon (lagmodell) for k = 3, k = 5 og k = 10
# lag_model_3 <- lagsarlm(Kev_model, data = Analyse_sf, listw = Analyse_sf_W3)
# lag_model_5 <- lagsarlm(Kev_model, data = Analyse_sf, listw = Analyse_sf_W5)
# lag_model_10 <- lagsarlm(Kev_model, data = Analyse_sf, listw = Analyse_sf_W10)

# Vis resultater fra modellene
# summary(lag_model_3)
# summary(lag_model_5)
# summary(lag_model_10)
```


# Lager modeller


## Modell 1

```{r}
mod1 <- "P ~ EL.Kar + O.Karak_num + MatValg_num"
```

## Modell 2

Punkt 2: Vi må finne ut kva variablar vi må ha "ln" framfor og kva variablar vi skal ha "I" framfor for å beholde formatering.

```{r}
#Fant problemet: Kan ikkje ta variabel BRA.Annet i SF_datasett, grunna alle verdiane e 0
mod2 <- "P ~ Alder + BLEnergikWh + Oms.Typ + BolType + AntEiendom + EiendomAreal + VannkantGL + VegkantGL + RegLBE + RegGrunnforur + RegKulturEiendom + RegGrunnerverv + RegBoDrivePlikt + TotBoliger + BRA.Bolig + BRA.Tot + BebygdAreal + RegKulturByg + Etasje + Lopenr + Bruksareal.Enhet + AntallRom + AntallBad + AntallWC + PrivatEid + HarHeis + EtasjeSeksjon + Kjokken + VannKode + AvlopsKode + YearQuarter"
```

## Modell 3

Punkt 2: Vi må finne ut kva variablar vi må ha "ln" framfor og kva variablar vi skal ha "I" framfor for å beholde formatering.

```{r}
mod3 <- "P ~ Alder + EL.Kar + O.Karak_num + BLEnergikWh + MatValg_num + Oms.Typ + BolType + AntEiendom + EiendomAreal + VannkantGL + VegkantGL + RegLBE + RegGrunnforur + RegKulturEiendom + RegGrunnerverv + RegBoDrivePlikt + TotBoliger + BRA.Bolig + BRA.Tot + BebygdAreal + RegKulturByg + Etasje + Lopenr + Bruksareal.Enhet + AntallRom + AntallBad + AntallWC + PrivatEid + HarHeis + EtasjeSeksjon + Kjokken + VannKode + AvlopsKode + YearQuarter + dist_cbd_km"
```

## Modell 4

```{r}
mod4 <- "P ~ EL.Kar"
```

# Kjører OLS-Modellen på våres modeller

## OLS1

```{r}
OLS1 = lm(mod1, data = Analyse_sf)
```
I OLS1 kan vi tolke;
- *(Intercept)*: 2,872,115 er den estimerte gjennomsnittlige boligprisen når alle de uavhengige variablene er 0. 

- *EL.Kar*: For hver enhet økning i energikarakteren, øker den estimerte boligprisen med 34,119, gitt at de andre variablene holdes konstante.

- *O.Karak_num*: For hver enhet økning i oppvarmingskarakteren, øker den estimerte boligprisen med 161,665, gitt at de andre variablene holdes konstante.

- *MatValg_num*: For hver enhet økning i materialevalg for boligens konstruksjon, øker den estimerte boligprisen med 89,045, gitt at de andre variablene holdes konstante. Dette blir ikke helt riktig fordi en økning i materialevalg ikke gjenspeiler virkeligheten.

I dette tilfellet er p-verdiene for alle variablene statistisk signifikante på 0,05-nivå, noe som betyr at det er bevis for at disse variablene har en effekt på boligprisen. Den minst signifikante variabelen er EL.Kar (p-verdi = 0,0457), mens de andre variablene har p-verdier som er mye lavere enn 0,05.

Imidlertid er forklaringskraften i modellen ganske lav, noe som tyder på at det kan være andre faktorer som også påvirker boligprisene som ikke er inkludert i modellen.
```{r}
summary(OLS1)
```

## OLS2

Punkt 2: Vi må finne ut kva variablar vi må ha "ln" framfor og kva variablar vi skal ha "I" framfor for å beholde formatering.

```{r}
OLS2 = lm(mod2, data = Analyse_sf)
```

```{r}
summary(OLS2)
```

## OLS3

Punkt 2: Vi må finne ut kva variablar vi må ha "ln" framfor og kva variablar vi skal ha "I" framfor for å beholde formatering.

```{r}
OLS3 = lm(mod3, data = Analyse_sf)
```

```{r}
summary(OLS3)
```

## OLS4

```{r}
OLS4 = lm(mod4, data = Analyse_sf)
```

```{r}
#summary(OLS4)
```

## Kevins regresjon
```{r}
OLS5 = lm(P ~ Alder + B.Ar + EL.Kar + O.Karak_num + BLEnergikWh + MatValg_num + AntEiendom + EiendomAreal + TotBoliger + BRA.Bolig + Etasje_num + dist_cbd_km, data = Analyse_sf)
summary(OLS5)
```


# HuxReg av OLS-modeller

```{r}
#Ekje heilt oppe å går endo. Jobbe med da.

huxreg("OLS1" = OLS1, "OLS2" = OLS2, "OLS3" = OLS3,
       coefs = c("(Intercept)", "EL.Kar", "O.Karak_num", "MatValg_num"), #Lagt til filter på enkelte variabler
       error_format = "[{statistic}]",
       note = "{stars}. T statistic in brackets.")
```
I huxreg ser vi følgende;
Resultatene for *OLS2* og *OLS3* viser svært høye R-kvadrat-verdier på 0,92, noe som tyder på at modellene forklarer 92% av variasjonen i boligprisene. Imidlertid er det verdt å merke seg at koeffisientene for de uavhengige variablene i disse modellene ikke er statistisk signifikante (p-verdiene > 0,05). Dette betyr at vi ikke kan konkludere med at de uavhengige variablene har en signifikant effekt på boligprisene i disse modellene.
- OLS2 og OLS3 har høyere *logLik*-verdier enn OLS1, noe som indikerer at de passer bedre til dataene.
-OLS2 og OLS3 har lavere *AIC*-verdier enn OLS1, noe som tyder på at de gir en bedre balanse mellom tilpasning og kompleksitet.

# Moran's Test

## Moran's - OLS1
```{r}
lm.morantest(OLS1, Analyse_sf_W3)
lm.morantest(OLS1, Analyse_sf_W5)
lm.morantest(OLS1, Analyse_sf_W10)
```
For alle tre romlige vektmatrisene (k = 3, 5, 10) viser Moran's I-test betydelig romlig autokorrelasjon i residualene til OLS-modellen:
*k = 3: Observed Moran I = 0.376, p-verdi < 2.2e-16*
*k = 5: Observed Moran I = 0.325, p-verdi < 2.2e-16*
*k = 10: Observed Moran I = 0.242, p-verdi < 2.2e-16*
Dette indikerer at det er romlige mønstre i modellens feil som ikke er fanget av de uavhengige variablene, og en romlig regresjonsmodell bør vurderes.

## Moran's - OLS2

```{r}
lm.morantest(OLS2, Analyse_sf_W3)
lm.morantest(OLS2, Analyse_sf_W5)
lm.morantest(OLS2, Analyse_sf_W10)
```
For alle tre romlige vektmatrisene (k = 3, 5, 10) viser Moran's I-test for OLS2-modellen:
*k = 3: Observed Moran I = -0.165, p-verdi = 0.9947*
*k = 5: Observed Moran I = -0.122, p-verdi = 0.9898*
*k = 10: Observed Moran I = -0.080, p-verdi = 1.0*
I motsetning til OLS1, viser disse resultatene at det ikke er betydelig romlig autokorrelasjon i residualene til OLS2-modellen for de valgte romlige vektmatrisene. Dette indikerer at modellen fanger romlige mønstre i dataene bedre enn OLS1, og at en romlig regresjonsmodell kanskje ikke er nødvendig i dette tilfellet.

## Moran's - OLS3

```{r}
lm.morantest(OLS3, Analyse_sf_W3)
lm.morantest(OLS3, Analyse_sf_W5)
lm.morantest(OLS3, Analyse_sf_W10)
```
*k = 3: Observed Moran I = -0.1653628, p-verdi = 0.9947*
*k = 5: Observed Moran I = -0.1223350, p-verdi = 0.9947*
*k = 10: Observed Moran I = -0.08005172, p-verdi = 0.9947*
Alle p-verdiene er større enn 0.05, som indikerer at det ikke er statistisk signifikant romlig autokorrelasjon i modellen. De negative verdiene for Observed Moran I indikerer imidlertid en viss grad av romlig heterogenitet i modellen. Modellen har lavere romlig autokorrelasjon når vi øker antallet naboer fra 3 til 10.
## Moran's - OLS4
```{r}
lm.morantest(OLS4, Analyse_sf_W3)
lm.morantest(OLS4, Analyse_sf_W5)
lm.morantest(OLS4, Analyse_sf_W10)
```
Her får vi 0.3864, 0.3309, og 0.2435 for k=3, k=5, og k=10, med p-verdier som er mindre enn 0,05-nivået. Dette indikerer at det er en romlig avhengighet mellom residualene, og at det er romlig autokorrelasjon i dataene. Dette betyr at det er en tendens til at boliger som ligger nær hverandre, har lignende residualer, og at det kan være en romlig struktur i dataene som ikke tas hensyn til i modellen.

# Korrelasjonsmatriser

## Sjekket for korrelasjon og multikollinearitet

Sjekk korrelasjon mellom
- EiendomAreal
- BRA.Bolig
- BRA.Annet
- BRA.Tot
- BebygdAreal
- Bruksareal.Enhet
```{r}
cor_matrix <- cor(Analyse[c("EiendomAreal", "BRA.Bolig", "BRA.Annet", "BRA.Tot", "BebygdAreal", "Bruksareal.Enhet")])
print(cor_matrix)
```

Sjekker multikollinearitet
```{r}
library(car)
vif_values <- vif(lm(EiendomAreal ~ BRA.Bolig + BebygdAreal + Bruksareal.Enhet, data = Analyse_sf))
print(vif_values)
```
En GVIF-verdi på mindre enn 5 regnes som akseptabelt for å unngå signifikant multikollinearitet. Her har BRA.Bolig og BebygdAreal en GVIF-verdi på henholdsvis 2.03 og 1.87, som indikerer at det ikke er noen signifikant multikollinearitet mellom dem. Bruksareal.Enhet har også en lav GVIF-verdi på 1.75, selv om antallet koeffisienter i modellen er høyt (220), som kan tyde på at det ikke er noen signifikant multikollinearitet mellom denne variabelen og de andre variablene i modellen. Dermed er det sannsynlig at disse variablene kan brukes sammen i en regresjonsmodell uten å påvirke modellens prediktive kraft eller nøyaktighet negativt på grunn av multikollinearitet.

```{r}
cor_matrix <- cor(Analyse_sf[c("P", "EL.Kar", "Alder", "B.Ar", "Etasje", "AntallRom")])

ggcorrplot(cor_matrix)
```

```{r}
correlation <- cor(Analyse_sf$dist_cbd_km, Analyse$P, method = "pearson")

#print(correlation)
```

```{r}
cor_matrix <- cor(Analyse_sf[c("P", "EL.Kar", "Alder", "Etasje", "AntallRom")])

ggcorrplot(cor_matrix, type = "lower", hc.order = TRUE, lab = TRUE)
```

```{r}
#Siste
```
